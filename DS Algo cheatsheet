可能用到的非课程知识点：
1.defaultdict可以用来创建键去重的字典。
引用方式:from collections import defaultdict
2.A是一个列表，A[~i]表示A的倒数第i项。
3.enumerate函数可以实现对一个数组中的元素匹配对应的指标。
4.permutations函数可以呈现数组中任取若干项排列组合
引用方式：from itertools import permutations
可能用到的本课程知识点：
1.类
要规定init等函数，很重要但是很难。
2.栈与队列
栈：一端进一端出；队列：一端进另一端出
3.树
掌握递归定义，节点，边，父子兄弟节点，层级，深度等概念
4.排序
冒泡排序：左右大小相反就互换位置，平均复杂度、最坏复杂度o(n^2)；
选择排序：每次遍历把最小的放在未排好的第一项，平均复杂度、最坏复杂度o(n^2);
插入排序：从前往后把每一项插入前面已经排好的序列的正确位置，平均复杂度、最坏复杂度o(n^2);
希尔排序：分组插入排序，然后合并，平均复杂度o(n^4/3)，最坏复杂度o(n^3/2);
快排：选取一个基准，比基准大的放右边，小的放左边，递归处理，平均复杂度o(nlogn),最坏复杂度o(n^2);
归并排序:申请额外空间，双指针移动，小的先放，大的后放，分治策略，平均复杂度、最坏复杂度o(nlogn)
可能用到的源代码：
1.快排
def quicksort(arr, left, right):
    if left < right:
        partition_pos = partition(arr, left, right)
        quicksort(arr, left, partition_pos - 1)
        quicksort(arr, partition_pos + 1, right)


def partition(arr, left, right):
    i = left
    j = right - 1
    pivot = arr[right]#选定基准
    while i <= j:
        while i <= right and arr[i] < pivot:
            i += 1
        while j >= left and arr[j] >= pivot:
            j -= 1
        if i < j:
            arr[i], arr[j] = arr[j], arr[i]
    if arr[i] > pivot:
        arr[i], arr[right] = arr[right], arr[i]
    return i


arr = [22, 11, 88, 66, 55, 77, 33, 44]#这里是举个例子
quicksort(arr, 0, len(arr) - 1)
print(arr)
2.归并排序
def mergeSort(arr):
	if len(arr) > 1:
		mid = len(arr)//2

		L = arr[:mid]	# Dividing the array elements
		R = arr[mid:] # Into 2 halves

		mergeSort(L) # Sorting the first half
		mergeSort(R) # Sorting the second half

		i = j = k = 0
		# Copy data to temp arrays L[] and R[]
		while i < len(L) and j < len(R):
			if L[i] <= R[j]:
				arr[k] = L[i]
				i += 1
			else:
				arr[k] = R[j]
				j += 1
			k += 1

		# Checking if any element was left
		while i < len(L):
			arr[k] = L[i]
			i += 1
			k += 1

		while j < len(R):
			arr[k] = R[j]
			j += 1
			k += 1
注:如果需要同时知道数组的逆序数，可采用如下代码
def mergesort(a):
    if len(a)<=1:
        return a,0
    mid=len(a)//2
    left,nixuleft=mergesort(a[:mid])
    right,nixuright=mergesort(a[mid:])
    merged,nixumerge=merge(left,right)
    return merged,nixuleft+nixuright+nixumerge
def merge(left,right):
    merged=[]
    ans=0
    i=j=0
    while i<len(left) and j<len(right):
        if left[i]<=right[j]:
            merged.append(left[i])
            i+=1
        else:
            merged.append(right[j])
            j+=1
            ans+=len(left)-i#考虑的是两个之间的逆序数
    merged+=left[i:]#如果还有剩余就放回新列表里面
    merged+=right[j:]
    return merged,ans #返回值为排好序的列表与逆序数


            


